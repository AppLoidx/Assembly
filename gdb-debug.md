# GDB

`gdb` это мощный отладчик, который можно использовать для изучения
функционирования программы. Он позволяет выполнять программы по шагам и изучать
её состояние, включая слепок памяти и регистров. Чтобы отлаживать программу
зачастую мы исполяем её по шагам и следим за состоянием. Мы также можем
исполнять её пока некоторое условие не станет истинным или до определённого
места в коде. Такое место называется `breakpoint`.

У `gdb` есть собственная система команд, управляющая программой, которую вы
изучаете. Поэтому когда вы запускаете `gdb` вы видите его приглашение командной
строки, куда вы и вводите команды.

## Запуск программы в `gdb`

Есть два основных способа использовать `gdb` с программой: с помощью его
собственной команды `file`, или запустив с путём к программе в качестве
аргумента.

```
(gdb) file hello
Reading symbols from hello ...(no debugging symbols found)...done.
```

## Основные команды

**С помощью клавиши `<tab>` вы можете вызывать автодополнение.**

Две самые важные команды:

* `quit` выход
* `help cmd` справка по команде `cmd`


### Файл `.gdbinit`

Команды из файла `~/.gdbinit` выполняются при старте `gdb`. 
Добавьте туда строчку:

```
set auto-load safe-path /
```

Тогда вы сможете создавать файл `.gdbinit` и в директории с файлом, который вы
отлаживаете.


### Переключение на Intel синтаксис

По умолчанию `gdb` для ассемблера использует AT&T синтаксис. Чтобы перманентно переключиться на Intel-синтаксис добавьте в `.gdbinit`:

```
set disassembly-flavor intel
```

### Команды управления программой

Ещё некоторые полезные команды `gdb` (текст в `<угловых скобках>` заменяется на аргументы):

* `run` запускает выполнение программы;
* `break <метка>` ставит точку останова на метку. Во время работы программы с подключенным отладчиком она будет останавливаться как только доходит до такой точки;
* `break *<адрес>` ставит точку останова на определённый адрес;
* `continue` продолжает выполнение программы;
* `stepi` (сокращённо `si`) выполняет ровно одну инструкцию;
* `nexti` (сокращённо `ni`) выполняет ровно одну инструкцию, но не заходит в функции, вызванные с помощью инструкции ассемблера `call`. Будет выполнена вся функция и программа остановится на следующей в коде после `call` инструкции.
* `layout` переключается между режимами интерфейса, см. далее.

## Запуск и исследование программы

Загрузим программу в отладчик, установим брейкпоинт на метку `_start`, с которой начинается выполнение любой ассемблерной программы, и запустим её.

![gdb1](https://i.imgur.com/9cNNpGl.png)
![gdb1](https://i.imgur.com/EtNduc1.png)


Чтобы нам было удобнее наблюдать состояние программы, мы включим режим псевдографики.

```
layout asm
layout regs
```

В этом режиме есть три окна:

* Вверху видны названия регистров и их текущие значения;
* В средней части виден результат дизассемблирования программы;
* Внизу вы по прежнему можете вводить команды.


В фокусе находится только одно из этих окон; с помощью `Ctrl-X` и `o` вы
можете менять фокус и затем взаимодействовать с другими окнами.
Стрелками можно скроллить окно, на котором установлен фокус.

### Состояние программы

В следующих двух командах используется обозначение `/FMT` для указания формата данных.

* `print /FMT <val>` позволяет посмотреть содержимое регистров или памяти. Регистры предваряются долларом, например, `print /x $rax`.
* `x /FMT <address>` позволяет смотреть содержимое памяти. Он отличается от `print` тем, что принимает адрес, т.е. имеет один уровень косвенности.

`/FMT` позволяет нам явно указывать тип данных, который мы изучаем. В зависимости от него меняются две вещи:

* формат отображения (например, основание системы счисления);
* ожидаемый размер. 

Например, в памяти лежит двоичное число `0xff78`. Если мы считаем 1 байт равный `0x78`, то это число мы интерпретируем как положительное; если же мы считаем 2 байта, то оно может быть интерпретировано как отрицательное (почему?)


Самые полезные форматы:

* `x` (hexadecimal) 
* `a` (address)
* `i` (instruction, `gdb` попытается дизассемблировать инструкцию начиная с данного адреса)
* `c` (char)
* `s` (null-terminated string) -- строка, в которой каждый байт соответствует
  коду символа по таблице ASCII, а конец строки обозначен символом с кодом
  `0x00`.

Самые полезные размеры: `b` (байт) `g` (giant, 8 байт).


## Примеры команд


* Посмотреть содержимое `rax`:

```
(gdb) print $rax
$1 = 1234605616436508552
```

* Посмотреть первый символ строчки которая находится на метке `msg`:

```
(gdb) print /c codes
$2 = '0'
```


* Дизассемблирование инструкции по адресу `_start` (тут используется оператор `&` для взятия адреса метки):

```
(gdb) x /i &_start
   0x4000b0 <_start>:   movabs rax,0x1122334455667788
```
* Дизассемблирование следующей инструкции:

```
(gdb) x /i $rip
=> 0x4000e9 <_start.loop+32>:   jne    0x4000c9 <_start.loop>
```

* Чему равны 12 первых символов начиная с метки `message`?

```
(gdb) x /5cb &message
0x402000 <message>:     104 'h' 101 'e' 108 'l' 108 'l' 111 'o'
```

Формат может начинаться с указания количества элементов. Поэтому `/12cb` означает "12 элементов-символов, каждый по 1 байту".


* Посмотреть последние 8 байт в стеке:

```
(gdb) x /xg $rsp
0x7fffffffdf90: 0x0000000000000001
```


* Посмотреть второй элемент размера `qword` (8 байт) в стеке:
    
```
(gdb) x/xg $rsp+8
0x7fffffffd168:	0x00007fffffffd513
```

> **Вопрос** прочитайте `help x`.

Чтобы использовать `gdb` эффективно, не забывайте про ключ компиляции `-g`.

Кроме того, `gdb` позволяет перемещаться и изучать стек вызовов, вычислять арифметические выражения, запускать функции, автоматизировать отладку с помощью скриптов на Python и многое другое. 

